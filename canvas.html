<style>
body, html, div {
    margin: 0;
    padding: 0;
}
canvas {
    width: 100vw;
    height: 100vh;
}

/* color canvas */
div#colors {
    display: flex;
    position: absolute;
    top: 20px;
    right: 20px;
    width: 300px;
    height: 42px;
    box-shadow: 1px 1px 30px rgba(255,255,255,0.2);
    border: 2px solid #555;
}

div#colors color {
    flex: 1;
    background-color: attr(hex type(<color>), red);
}
</style>

<canvas id=canvas width=500 height=500></canvas>

<div id=colors>
    <color hex=#ff0000></color>
    <color hex=#00ff00></color>
    <color hex=#0000ff></color>
    <color hex=#ffff00></color>
    <color hex=#00ffff></color>
    <color hex=#ff00ff></color>
    <color hex=#4a412a></color>
</div>

<script src="pubnub.js"></script>
<script>
// TODO mobile support (on touchstart touchend touchmove )
// TODO draw line between last and current position
// TODO check when mouse click is down <-- WARNING mobile
const pubnub     = PubNub({});
const channel    = 'shared-canvas';
const width      = 500;
const height     = 500;
const body       = document.querySelector('body');
const pageWidth  = body.clientWidth;
const pageHeight = body.clientHeight;
const canvas     = document.getElementById('canvas');
const context    = canvas.getContext('2d');
const context2   = canvas.getContext('2d');
let drawing      = false;

// Fill background with dark mode because Janlu
context.fillStyle = "#181818";
context.fillRect(0, 0, canvas.width, canvas.height);

// Set draw style
context.lineWidth = 5;
context.fillStyle = 'red';
context.strokeStyle = 'red';

canvas.addEventListener( 'mousedown', (event) => {
    drawing = true;
    context.beginPath();
    const coords = getXY(event);
    context.moveTo(coords.x, coords.y);
});
canvas.addEventListener( 'mouseup', (event) => {
    drawing = false;
});
canvas.addEventListener( 'mousemove', (event) => {
    if (!drawing) return;
    const coords = getXY(event);
    const x = coords.x;
    const y = coords.y;
    context.lineTo(x, y);
    context.stroke(); 

    // Prevent broadcast unless we have enough data
    if (previous.x){
        broadcast(previous.x, x, previous.y, y, context.strokeStyle);
    }

    // Save last position for connecting lines on subscription
    previous.x = x;
    previous.y = y;
});

function getXY(event) {
    const x = Math.floor((event.offsetX / pageWidth) * width);
    const y = Math.floor((event.offsetY / pageHeight) * height);

    return {x:x, y:y};
}

const colors = document.getElementById('colors');
colors.addEventListener( 'click', (event) => {
    const target = event.target;
    const color = target.getAttribute('hex');
    if (!color) return;
    context.strokeStyle = color;
});

// Multi-user canvas
function draw(x1, x2, y1, y2, style) {
    console.log(x1, x2, y1, y2, style);
}

pubnub.subscribe({
    channel: channel,
    messages: (message) => {
        draw(
            message.x1,
            message.y1,
            message.x2,
            message.y2,
            message.style
        );
    }
});
let previous = { x: 0, y: 0 };
function broadcast(x1, x2, y1, y2, style) {
    pubnub.publish({
        channel: channel,
        message: {
            x1: x1,
            x2: x2,
            y1: y1,
            y2: y2,
            style: style,
        },
    });
}

</script>
