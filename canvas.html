<style>
body, html, div {
    margin: 0;
    padding: 0;
}
canvas {
    width: 100vw;
    height: 100vh;
}

/* color canvas */
div#colors {
    display: flex;
    position: absolute;
    top: 20px;
    right: 20px;
    min-width: 300px;
    gap: 4px;
    height: 44px;
    box-shadow: 1px 1px 20px rgba(0,0,0,0.3);
    
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.1);
    padding: 8px;
    border-radius: 16px;

    backdrop-filter: blur(4px);
}

div#colors color {
    flex: 1;
    min-width: 40px;
    background-color: attr(hex type(<color>), red);
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.2);

    transition: all 150ms cubic-bezier(.2,0,0,1);
}

div#colors color:active {
    scale: 0.4;
}
</style>

<canvas id=canvas width=500 height=500></canvas>

<div id=colors>
    <color hex=#ff0000></color>
    <color hex=#00ff00></color>
    <color hex=#0000ff></color>
    <color hex=#ffff00></color>
    <color hex=#00ffff></color>
    <color hex=#ff00ff></color>
    <color hex=#4a412a></color>
</div>

<script src="pubnub.js"></script>
<script>
// TODO context per remote user ( so each user can draw )
// TODO mobile support (on touchstart touchend touchmove )
// TODO draw line between last and current position
// TODO check when mouse click is down <-- WARNING mobile
const pubnub     = PubNub({});
const channel    = 'shared-canvas';
const width      = 500;
const height     = 500;
const body       = document.querySelector('body');
const pageWidth  = body.clientWidth;
const pageHeight = body.clientHeight;
const canvas     = document.getElementById('canvas');
const context    = canvas.getContext('2d');
const remoteCtx  = canvas.getContext('2d');
let drawing      = false;

// Fill background with dark mode because Janlu
context.fillStyle = "#181818";
context.fillRect(0, 0, canvas.width, canvas.height);

// Set remote context draw styel
remoteCtx.lineWidth = 5;
remoteCtx.fillStyle = 'red';
remoteCtx.strokeStyle = 'red';

// Set draw style
context.lineWidth = 5;
context.fillStyle = 'red';
context.strokeStyle = 'red';

canvas.addEventListener( 'touchstart', (event) => {
    drawing = true;
    context.beginPath();
    const coords = getXY(event);
    context.moveTo(coords.x, coords.y);
});
canvas.addEventListener( 'mousedown', (event) => {
    drawing = true;
    context.beginPath();
    const coords = getXY(event);
    context.moveTo(coords.x, coords.y);
});
canvas.addEventListener( 'mouseup', (event) => {
    drawing = false;
});
canvas.addEventListener( 'touchend', (event) => {
    drawing = false;
});
canvas.addEventListener( 'touchmove', (event) => {
    if (!drawing) return;
    const coords = getXY(event);
    const x = coords.x;
    const y = coords.y;
    context.lineTo(x, y);
    context.stroke(); 

    // Prevent broadcast unless we have enough data
    if (previous.x) {
        broadcast(previous.x, previous.y, x, y, context.strokeStyle);
    }

    // Save last position for connecting lines on subscription
    previous.x = x;
    previous.y = y;
});
canvas.addEventListener( 'mousemove', (event) => {
    if (!drawing) return;
    const coords = getXY(event);
    const x = coords.x;
    const y = coords.y;
    context.lineTo(x, y);
    context.stroke(); 

    // Prevent broadcast unless we have enough data
    if (previous.x) {
        broadcast(previous.x, previous.y, x, y, context.strokeStyle);
    }

    // Save last position for connecting lines on subscription
    previous.x = x;
    previous.y = y;
});

function getXY(event) {
    const x = Math.floor((event.offsetX / pageWidth) * width);
    const y = Math.floor((event.offsetY / pageHeight) * height);

    return {x:x, y:y};
}

const colors = document.getElementById('colors');
colors.addEventListener( 'click', (event) => {
    const target = event.target;
    const color = target.getAttribute('hex');
    if (!color) return;
    context.strokeStyle = color;
});

// Multi-user canvas
function draw(x1, x2, y1, y2, style) {
    context.strokeStyle = style;
    remoteCtx.beginPath();
    remoteCtx.moveTo(x1, y1);
    remoteCtx.lineTo(x2, y2);
    remoteCtx.stroke(); 
}

pubnub.subscribe({
    channel: channel,
    messages: (message) => {
        draw(
            message.x1,
            message.y1,
            message.x2,
            message.y2,
            message.style
        );
    }
});
let previous = { x: 0, y: 0 };
function broadcast(x1, x2, y1, y2, style) {
    pubnub.publish({
        channel: channel,
        message: {
            x1: x1,
            x2: x2,
            y1: y1,
            y2: y2,
            style: style,
        },
    });
}

</script>
